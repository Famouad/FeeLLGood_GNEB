/** \file config.h
config.h is generated by cmake from config.h.in
*/

#ifndef CONFIG_H
#define CONFIG_H

#include <cmath>
#include <string>
#include "gmm/gmm_kernel.h"

const std::string feellgood_version = "@FEELLGOOD_VERSION@" ; /**< human readable version */

#define SHAnumber @SHAstr@ /**< SHA1 number of the git repository (HEAD) */

#define MaxNbThreads @MAX_NB_THREADS@ /**< maximum number of threads available */

/* macros for messages and errors */
#ifdef LIBRARY
	#include <stdexcept>  // for runtime_error
	#include <cerrno>
	#include <system_error>
	
	#define SYSTEM_ERROR {throw system_error(errno,generic_category());}/**< macro for error handling if feellgood compiled as a library */
#else
	
	#define SYSTEM_ERROR {exit(1);} /**< macro to exit executable on some errors */
#endif


typedef gmm::wsvector <double>   write_vector;/**< gmm write vector build on std::map, log(n) for read and write access */
typedef gmm::rsvector <double>   read_vector; /**< gmm read vector */

typedef gmm::row_matrix	<write_vector>   write_matrix; /**< gmm write sparse matrix */
typedef gmm::row_matrix	<read_vector>    read_matrix; /**< gmm read sparse matrix */

const double mu0 = 4.*M_PI*1e-7;/**< \f$ \mu_0 = 4 \pi 10^{-7} \f$ */
const double nu0 = 1./mu0;/**< \f$ \nu_0 = 1/\mu_0 \f$ */
const double PLANCKS_H    	= 6.62606896e-34;   /**< kg m^2 / s */
const double PLANCKS_HBAR 	= 1.05457162825e-34; /**< kg m^2 / s */
const double CHARGE_ELECTRON 	= 1.602176487e-19;   /**< C */
const double MASS_ELECTRON 	= 9.10938188e-31;   /**< kg */
const double BOHRS_MUB = CHARGE_ELECTRON*PLANCKS_HBAR/(2.*MASS_ELECTRON);

/** for debugging purpose, some determinist pseudo random number for ep,eq vector basis can be used */
#define RAND_DETERMINIST true

/** theta of the theta integration scheme in time */
#define THETA 0.5

/** this constant is depending on the mesh, \f$ \epsilon \f$ is a small value, used to modify slightly J in (tet|facette).integrales */
#define EPSILON 1e-40
//should not be fixed but computed with an analysis of the mesh

/** USER_TOL is tolerance for 'unit' vector input values : if abs(norm(x)-1) < USER_TOL then x is a unit vector */
#define USER_TOL 1e-8

/** tolerance for some unit tests involving some numerical errors */
#define UT_TOL 1e-15

#endif //CONFIG_H
